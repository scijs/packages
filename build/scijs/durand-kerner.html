<h1 id="durand-kerner"><a target="_blank" href="http://github.com/scijs/durand-kerner">durand-kerner</a></h1>
<p>Finds all the roots of a polynomial by <a href="http://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method">Weierstrass&apos; method</a> (or known in Abramowitz&amp;Stegun as the Durand-Kerner method).  This is basically a generalization of Newton&apos;s method that works for multiple roots.</p>
<p><a href="http://travis-ci.org/scijs/durand-kerner"><img src="https://secure.travis-ci.org/scijs/durand-kerner.png" alt="build status"></a></p>
<h1 id="example">Example</h1>
<p>To find the roots for <code>1 + 1*x - 1*x^2</code>:</p>
<pre><code class="lang-javascript"><span class="kd">var</span> <span class="nx">findRoots</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;durand-kerner&quot;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">roots</span> <span class="o">=</span> <span class="nx">findRoots</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1">// Now:</span>
<span class="c1">//      roots[0] = real part of roots</span>
<span class="c1">//      roots[1] = imaginary part of roots</span>

<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">roots</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;+&quot;</span> <span class="o">+</span> <span class="nx">roots</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<h3 id="output">Output</h3>
<pre><code> 1.618033988749895+0i
-0.6180339887498949+0i
</code></pre><h1 id="install">Install</h1>
<p>Install using npm:</p>
<pre><code>npm install durand-kerner
</code></pre><h1 id="api">API</h1>
<h4 id="-require-durand-kerner-r_coeff-i_coeff-n_iters-tolerance-initial-"><code>require(&quot;durand-kerner&quot;)(r_coeff[, i_coeff, n_iters, tolerance, initial])</code></h4>
<p>Finds the roots of a polynomial whose real coefficients are given by <code>r_coeff</code> and imaginary coefficients by <code>i_coeff</code>.</p>
<ul>
<li><code>r_coeff</code> - the real part of the polynomial&apos;s coefficients, stored in an array</li>
<li><code>i_coeff</code> - the imaginary part of the polynomial&apos;s coefficients (default all 0)</li>
<li><code>n_iters</code> - Maximum number of iterations to run before bailout. Default is <code>100 * n * n</code></li>
<li><code>tolerance</code> - Stopping threshold.  Default is <code>1e-6</code></li>
<li><code>initial</code> - Initial guess for solution vector (must have the same length as <code>r_coeff</code>).  This also gets the solution (optional)</li>
</ul>
<p><strong>Returns</strong> An array of roots.  </p>
<h1 id="license">License</h1>
<p>(c) 2013 Mikola Lysenko. MIT License</p>
